var Re=(p=>(p.uninitialized="uninitialized",p.pending="pending",p.fulfilled="fulfilled",p.rejected="rejected",p))(Re||{});function Be(e){return{status:e,isUninitialized:e==="uninitialized",isLoading:e==="pending",isSuccess:e==="fulfilled",isError:e==="rejected"}}import{createAction as L,createSlice as J,createSelector as Pe,createAsyncThunk as xe,combineReducers as ve,createNextState as ae,isAnyOf as G,isAllOf as de,isAction as Ce,isPending as pe,isRejected as Z,isFulfilled as O,isRejectedWithValue as ee,isAsyncThunkAction as Ae,prepareAutoBatched as te,SHOULD_AUTOBATCH as Y,isPlainObject as z,nanoid as ce}from"@reduxjs/toolkit";var we=z;function le(e,r){if(e===r||!(we(e)&&we(r)||Array.isArray(e)&&Array.isArray(r)))return r;let f=Object.keys(r),S=Object.keys(e),p=f.length===S.length,R=Array.isArray(r)?[]:{};for(let A of f)R[A]=le(e[A],r[A]),p&&(p=e[A]===R[A]);return p?e:R}function U(e){let r=0;for(let f in e)r++;return r}var De=e=>[].concat(...e);function Fe(e){return new RegExp("(^|:)//").test(e)}function Ie(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function be(e){return e!=null}function Oe(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var pt=e=>e.replace(/\/$/,""),ct=e=>e.replace(/^\//,"");function qe(e,r){if(!e)return r;if(!r)return e;if(Fe(r))return r;let f=e.endsWith("/")||!r.startsWith("?")?"/":"";return e=pt(e),r=ct(r),`${e}${f}${r}`}var Ne=(...e)=>fetch(...e),lt=e=>e.status>=200&&e.status<=299,ft=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function Ke(e){if(!z(e))return e;let r={...e};for(let[f,S]of Object.entries(r))S===void 0&&delete r[f];return r}function mt({baseUrl:e,prepareHeaders:r=c=>c,fetchFn:f=Ne,paramsSerializer:S,isJsonContentType:p=ft,jsonContentType:R="application/json",jsonReplacer:A,timeout:M,responseHandler:k,validateStatus:Q,...D}={}){return typeof fetch>"u"&&f===Ne&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(o,n,g)=>{let{getState:a,extra:d,endpoint:u,forced:t,type:m}=n,h,{url:x,headers:T=new Headers(D.headers),params:i=void 0,responseHandler:l=k??"json",validateStatus:y=Q??lt,timeout:s=M,...E}=typeof o=="string"?{url:o}:o,b,B=n.signal;s&&(b=new AbortController,n.signal.addEventListener("abort",b.abort),B=b.signal);let P={...D,signal:B,...E};T=new Headers(Ke(T)),P.headers=await r(T,{getState:a,arg:o,extra:d,endpoint:u,forced:t,type:m,extraOptions:g})||T;let v=I=>typeof I=="object"&&(z(I)||Array.isArray(I)||typeof I.toJSON=="function");if(!P.headers.has("content-type")&&v(P.body)&&P.headers.set("content-type",R),v(P.body)&&p(P.headers)&&(P.body=JSON.stringify(P.body,A)),i){let I=~x.indexOf("?")?"&":"?",$=S?S(i):new URLSearchParams(Ke(i));x+=I+$}x=qe(e,x);let w=new Request(x,P);h={request:new Request(x,P)};let C,q=!1,N=b&&setTimeout(()=>{q=!0,b.abort()},s);try{C=await f(w)}catch(I){return{error:{status:q?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(I)},meta:h}}finally{N&&clearTimeout(N),b?.signal.removeEventListener("abort",b.abort)}let oe=C.clone();h.response=oe;let K,F="";try{let I;if(await Promise.all([c(C,l).then($=>K=$,$=>I=$),oe.text().then($=>F=$,()=>{})]),I)throw I}catch(I){return{error:{status:"PARSING_ERROR",originalStatus:C.status,data:F,error:String(I)},meta:h}}return y(C,K)?{data:K,meta:h}:{error:{status:C.status,data:K},meta:h}};async function c(o,n){if(typeof n=="function")return n(o);if(n==="content-type"&&(n=p(o.headers)?"json":"text"),n==="json"){let g=await o.text();return g.length?JSON.parse(g):null}return o.text()}}var j=class{constructor(r,f=void 0){this.value=r;this.meta=f}};async function gt(e=0,r=5){let f=Math.min(e,r),S=~~((Math.random()+.4)*(300<<f));await new Promise(p=>setTimeout(R=>p(R),S))}function Tt(e){throw Object.assign(new j({error:e}),{throwImmediately:!0})}var Ue={},ht=(e,r)=>async(f,S,p)=>{let R=[5,(r||Ue).maxRetries,(p||Ue).maxRetries].filter(D=>D!==void 0),[A]=R.slice(-1),k={maxRetries:A,backoff:gt,retryCondition:(D,c,{attempt:o})=>o<=A,...r,...p},Q=0;for(;;)try{let D=await e(f,S,p);if(D.error)throw new j(D);return D}catch(D){if(Q++,D.throwImmediately){if(D instanceof j)return D.value;throw D}if(D instanceof j&&!k.retryCondition(D.value.error,f,{attempt:Q,baseQueryApi:S,extraOptions:p}))return D.value;await k.backoff(Q,k.maxRetries)}},Qt=Object.assign(ht,{fail:Tt});var V=L("__rtkq/focused"),ne=L("__rtkq/unfocused"),W=L("__rtkq/online"),re=L("__rtkq/offline"),Ee=!1;function St(e,r){function f(){let S=()=>e(V()),p=()=>e(ne()),R=()=>e(W()),A=()=>e(re()),M=()=>{window.document.visibilityState==="visible"?S():p()};return Ee||typeof window<"u"&&window.addEventListener&&(window.addEventListener("visibilitychange",M,!1),window.addEventListener("focus",S,!1),window.addEventListener("online",R,!1),window.addEventListener("offline",A,!1),Ee=!0),()=>{window.removeEventListener("focus",S),window.removeEventListener("visibilitychange",M),window.removeEventListener("online",R),window.removeEventListener("offline",A),Ee=!1}}return r?r(e,{onFocus:V,onFocusLost:ne,onOffline:re,onOnline:W}):f()}function me(e){return e.type==="query"}function je(e){return e.type==="mutation"}function se(e,r,f,S,p,R){return Rt(e)?e(r,f,S,p).map(fe).map(R):Array.isArray(e)?e.map(fe).map(R):[]}function Rt(e){return typeof e=="function"}function fe(e){return typeof e=="string"?{type:e}:e}import{isDraftable as xt,produceWithPatches as At}from"immer";import"@reduxjs/toolkit";function Le(e,r){return e.catch(r)}var ie=Symbol("forceQueryFn"),ue=e=>typeof e[ie]=="function";function He({serializeQueryArgs:e,queryThunk:r,mutationThunk:f,api:S,context:p}){let R=new Map,A=new Map,{unsubscribeQueryResult:M,removeMutationResult:k,updateSubscriptionOptions:Q}=S.internalActions;return{buildInitiateQuery:a,buildInitiateMutation:d,getRunningQueryThunk:D,getRunningMutationThunk:c,getRunningQueriesThunk:o,getRunningMutationsThunk:n};function D(u,t){return m=>{let h=p.endpointDefinitions[u],x=e({queryArgs:t,endpointDefinition:h,endpointName:u});return R.get(m)?.[x]}}function c(u,t){return m=>A.get(m)?.[t]}function o(){return u=>Object.values(R.get(u)||{}).filter(be)}function n(){return u=>Object.values(A.get(u)||{}).filter(be)}function g(u){}function a(u,t){let m=(h,{subscribe:x=!0,forceRefetch:T,subscriptionOptions:i,[ie]:l,...y}={})=>(s,E)=>{let b=e({queryArgs:h,endpointDefinition:t,endpointName:u}),B=r({...y,type:"query",subscribe:x,forceRefetch:T,subscriptionOptions:i,endpointName:u,originalArgs:h,queryCacheKey:b,[ie]:l}),P=S.endpoints[u].select(h),v=s(B),w=P(E());let{requestId:_,abort:C}=v,q=w.requestId!==_,N=R.get(s)?.[b],oe=()=>P(E()),K=Object.assign(l?v.then(oe):q&&!N?Promise.resolve(w):Promise.all([N,v]).then(oe),{arg:h,requestId:_,subscriptionOptions:i,queryCacheKey:b,abort:C,async unwrap(){let F=await K;if(F.isError)throw F.error;return F.data},refetch:()=>s(m(h,{subscribe:!1,forceRefetch:!0})),unsubscribe(){x&&s(M({queryCacheKey:b,requestId:_}))},updateSubscriptionOptions(F){K.subscriptionOptions=F,s(Q({endpointName:u,requestId:_,queryCacheKey:b,options:F}))}});if(!N&&!q&&!l){let F=R.get(s)||{};F[b]=K,R.set(s,F),K.then(()=>{delete F[b],U(F)||R.delete(s)})}return K};return m}function d(u){return(t,{track:m=!0,fixedCacheKey:h}={})=>(x,T)=>{let i=f({type:"mutation",endpointName:u,originalArgs:t,track:m,fixedCacheKey:h}),l=x(i);let{requestId:y,abort:s,unwrap:E}=l,b=Le(l.unwrap().then(w=>({data:w})),w=>({error:w})),B=()=>{x(k({requestId:y,fixedCacheKey:h}))},P=Object.assign(b,{arg:l.arg,requestId:y,abort:s,unwrap:E,reset:B}),v=A.get(x)||{};return A.set(x,v),v[y]=P,P.then(()=>{delete v[y],U(v)||A.delete(x)}),h&&(v[h]=P,P.then(()=>{v[h]===P&&(delete v[h],U(v)||A.delete(x))})),P}}}function _e(e){return e}function ze({reducerPath:e,baseQuery:r,context:{endpointDefinitions:f},serializeQueryArgs:S,api:p,assertTagType:R}){let A=(t,m,h,x)=>(T,i)=>{let l=f[t],y=S({queryArgs:m,endpointDefinition:l,endpointName:t});if(T(p.internalActions.queryResultPatched({queryCacheKey:y,patches:h})),!x)return;let s=p.endpoints[t].select(m)(i()),E=se(l.providesTags,s.data,void 0,m,{},R);T(p.internalActions.updateProvidedBy({queryCacheKey:y,providedTags:E}))},M=(t,m,h,x=!0)=>(T,i)=>{let y=p.endpoints[t].select(m)(i()),s={patches:[],inversePatches:[],undo:()=>T(p.util.patchQueryData(t,m,s.inversePatches,x))};if(y.status==="uninitialized")return s;let E;if("data"in y)if(xt(y.data)){let[b,B,P]=At(y.data,h);s.patches.push(...B),s.inversePatches.push(...P),E=b}else E=h(y.data),s.patches.push({op:"replace",path:[],value:E}),s.inversePatches.push({op:"replace",path:[],value:y.data});return s.patches.length===0||T(p.util.patchQueryData(t,m,s.patches,x)),s},k=(t,m,h)=>x=>x(p.endpoints[t].initiate(m,{subscribe:!1,forceRefetch:!0,[ie]:()=>({data:h})})),Q=async(t,{signal:m,abort:h,rejectWithValue:x,fulfillWithValue:T,dispatch:i,getState:l,extra:y})=>{let s=f[t.endpointName];try{let E=_e,b,B={signal:m,abort:h,dispatch:i,getState:l,extra:y,endpoint:t.endpointName,type:t.type,forced:t.type==="query"?D(t,l()):void 0,queryCacheKey:t.type==="query"?t.queryCacheKey:void 0},P=t.type==="query"?t[ie]:void 0;if(P?b=P():s.query?(b=await r(s.query(t.originalArgs),B,s.extraOptions),s.transformResponse&&(E=s.transformResponse)):b=await s.queryFn(t.originalArgs,B,s.extraOptions,v=>r(v,B,s.extraOptions)),typeof process<"u",b.error)throw new j(b.error,b.meta);return T(await E(b.data,b.meta,t.originalArgs),{fulfilledTimeStamp:Date.now(),baseQueryMeta:b.meta,[Y]:!0})}catch(E){let b=E;if(b instanceof j){let B=_e;s.query&&s.transformErrorResponse&&(B=s.transformErrorResponse);try{return x(await B(b.value,b.meta,t.originalArgs),{baseQueryMeta:b.meta,[Y]:!0})}catch(P){b=P}}throw typeof process<"u",console.error(b),b}};function D(t,m){let h=m[e]?.queries?.[t.queryCacheKey],x=m[e]?.config.refetchOnMountOrArgChange,T=h?.fulfilledTimeStamp,i=t.forceRefetch??(t.subscribe&&x);return i?i===!0||(Number(new Date)-Number(T))/1e3>=i:!1}let c=xe(`${e}/executeQuery`,Q,{getPendingMeta(){return{startedTimeStamp:Date.now(),[Y]:!0}},condition(t,{getState:m}){let h=m(),x=h[e]?.queries?.[t.queryCacheKey],T=x?.fulfilledTimeStamp,i=t.originalArgs,l=x?.originalArgs,y=f[t.endpointName];return ue(t)?!0:x?.status==="pending"?!1:D(t,h)||me(y)&&y?.forceRefetch?.({currentArg:i,previousArg:l,endpointState:x,state:h})?!0:!T},dispatchConditionRejection:!0}),o=xe(`${e}/executeMutation`,Q,{getPendingMeta(){return{startedTimeStamp:Date.now(),[Y]:!0}}}),n=t=>"force"in t,g=t=>"ifOlderThan"in t,a=(t,m,h)=>(x,T)=>{let i=n(h)&&h.force,l=g(h)&&h.ifOlderThan,y=(E=!0)=>{let b={forceRefetch:E,isPrefetch:!0};return p.endpoints[t].initiate(m,b)},s=p.endpoints[t].select(m)(T());if(i)x(y());else if(l){let E=s?.fulfilledTimeStamp;if(!E){x(y());return}(Number(new Date)-Number(new Date(E)))/1e3>=l&&x(y())}else x(y(!1))};function d(t){return m=>m?.meta?.arg?.endpointName===t}function u(t,m){return{matchPending:de(pe(t),d(m)),matchFulfilled:de(O(t),d(m)),matchRejected:de(Z(t),d(m))}}return{queryThunk:c,mutationThunk:o,prefetch:a,updateQueryData:M,upsertQueryData:k,patchQueryData:A,buildMatchThunkActions:u}}function ge(e,r,f,S){return se(f[e.meta.arg.endpointName][r],O(e)?e.payload:void 0,ee(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,S)}import{isDraft as Dt}from"immer";import{applyPatches as Ve,original as bt}from"immer";function Te(e,r,f){let S=e[r];S&&f(S)}function X(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function We(e,r,f){let S=e[X(r)];S&&f(S)}var ye={};function $e({reducerPath:e,queryThunk:r,mutationThunk:f,serializeQueryArgs:S,context:{endpointDefinitions:p,apiUid:R,extractRehydrationInfo:A,hasRehydrationInfo:M},assertTagType:k,config:Q}){let D=L(`${e}/resetApiState`);function c(T,i,l,y){T[i.queryCacheKey]??={status:"uninitialized",endpointName:i.endpointName},Te(T,i.queryCacheKey,s=>{s.status="pending",s.requestId=l&&s.requestId?s.requestId:y.requestId,i.originalArgs!==void 0&&(s.originalArgs=i.originalArgs),s.startedTimeStamp=y.startedTimeStamp})}function o(T,i,l){Te(T,i.arg.queryCacheKey,y=>{if(y.requestId!==i.requestId&&!ue(i.arg))return;let{merge:s}=p[i.arg.endpointName];if(y.status="fulfilled",s)if(y.data!==void 0){let{fulfilledTimeStamp:E,arg:b,baseQueryMeta:B,requestId:P}=i,v=ae(y.data,w=>s(w,l,{arg:b.originalArgs,baseQueryMeta:B,fulfilledTimeStamp:E,requestId:P}));y.data=v}else y.data=l;else y.data=p[i.arg.endpointName].structuralSharing??!0?le(Dt(y.data)?bt(y.data):y.data,l):l;delete y.error,y.fulfilledTimeStamp=i.fulfilledTimeStamp})}let n=J({name:`${e}/queries`,initialState:ye,reducers:{removeQueryResult:{reducer(T,{payload:{queryCacheKey:i}}){delete T[i]},prepare:te()},cacheEntriesUpserted:{reducer(T,i){for(let l of i.payload){let{queryDescription:y,value:s}=l;c(T,y,!0,{arg:y,requestId:i.meta.requestId,startedTimeStamp:i.meta.timestamp}),o(T,{arg:y,requestId:i.meta.requestId,fulfilledTimeStamp:i.meta.timestamp,baseQueryMeta:{}},s)}},prepare:T=>({payload:T.map(y=>{let{endpointName:s,arg:E,value:b}=y,B=p[s];return{queryDescription:{type:"query",endpointName:s,originalArgs:y.arg,queryCacheKey:S({queryArgs:E,endpointDefinition:B,endpointName:s})},value:b}}),meta:{[Y]:!0,requestId:ce(),timestamp:Date.now()}})},queryResultPatched:{reducer(T,{payload:{queryCacheKey:i,patches:l}}){Te(T,i,y=>{y.data=Ve(y.data,l.concat())})},prepare:te()}},extraReducers(T){T.addCase(r.pending,(i,{meta:l,meta:{arg:y}})=>{let s=ue(y);c(i,y,s,l)}).addCase(r.fulfilled,(i,{meta:l,payload:y})=>{o(i,l,y)}).addCase(r.rejected,(i,{meta:{condition:l,arg:y,requestId:s},error:E,payload:b})=>{Te(i,y.queryCacheKey,B=>{if(!l){if(B.requestId!==s)return;B.status="rejected",B.error=b??E}})}).addMatcher(M,(i,l)=>{let{queries:y}=A(l);for(let[s,E]of Object.entries(y))(E?.status==="fulfilled"||E?.status==="rejected")&&(i[s]=E)})}}),g=J({name:`${e}/mutations`,initialState:ye,reducers:{removeMutationResult:{reducer(T,{payload:i}){let l=X(i);l in T&&delete T[l]},prepare:te()}},extraReducers(T){T.addCase(f.pending,(i,{meta:l,meta:{requestId:y,arg:s,startedTimeStamp:E}})=>{s.track&&(i[X(l)]={requestId:y,status:"pending",endpointName:s.endpointName,startedTimeStamp:E})}).addCase(f.fulfilled,(i,{payload:l,meta:y})=>{y.arg.track&&We(i,y,s=>{s.requestId===y.requestId&&(s.status="fulfilled",s.data=l,s.fulfilledTimeStamp=y.fulfilledTimeStamp)})}).addCase(f.rejected,(i,{payload:l,error:y,meta:s})=>{s.arg.track&&We(i,s,E=>{E.requestId===s.requestId&&(E.status="rejected",E.error=l??y)})}).addMatcher(M,(i,l)=>{let{mutations:y}=A(l);for(let[s,E]of Object.entries(y))(E?.status==="fulfilled"||E?.status==="rejected")&&s!==E?.requestId&&(i[s]=E)})}}),a=J({name:`${e}/invalidation`,initialState:ye,reducers:{updateProvidedBy:{reducer(T,i){let{queryCacheKey:l,providedTags:y}=i.payload;for(let s of Object.values(T))for(let E of Object.values(s)){let b=E.indexOf(l);b!==-1&&E.splice(b,1)}for(let{type:s,id:E}of y){let b=(T[s]??={})[E||"__internal_without_id"]??=[];b.includes(l)||b.push(l)}},prepare:te()}},extraReducers(T){T.addCase(n.actions.removeQueryResult,(i,{payload:{queryCacheKey:l}})=>{for(let y of Object.values(i))for(let s of Object.values(y)){let E=s.indexOf(l);E!==-1&&s.splice(E,1)}}).addMatcher(M,(i,l)=>{let{provided:y}=A(l);for(let[s,E]of Object.entries(y))for(let[b,B]of Object.entries(E)){let P=(i[s]??={})[b||"__internal_without_id"]??=[];for(let v of B)P.includes(v)||P.push(v)}}).addMatcher(G(O(r),ee(r)),(i,l)=>{let y=ge(l,"providesTags",p,k),{queryCacheKey:s}=l.meta.arg;a.caseReducers.updateProvidedBy(i,a.actions.updateProvidedBy({queryCacheKey:s,providedTags:y}))})}}),d=J({name:`${e}/subscriptions`,initialState:ye,reducers:{updateSubscriptionOptions(T,i){},unsubscribeQueryResult(T,i){},internal_getRTKQSubscriptions(){}}}),u=J({name:`${e}/internalSubscriptions`,initialState:ye,reducers:{subscriptionsUpdated:{reducer(T,i){return Ve(T,i.payload)},prepare:te()}}}),t=J({name:`${e}/config`,initialState:{online:Oe(),focused:Ie(),middlewareRegistered:!1,...Q},reducers:{middlewareRegistered(T,{payload:i}){T.middlewareRegistered=T.middlewareRegistered==="conflict"||R!==i?"conflict":!0}},extraReducers:T=>{T.addCase(W,i=>{i.online=!0}).addCase(re,i=>{i.online=!1}).addCase(V,i=>{i.focused=!0}).addCase(ne,i=>{i.focused=!1}).addMatcher(M,i=>({...i}))}}),m=ve({queries:n.reducer,mutations:g.reducer,provided:a.reducer,subscriptions:u.reducer,config:t.reducer}),h=(T,i)=>m(D.match(i)?void 0:T,i),x={...t.actions,...n.actions,...d.actions,...u.actions,...g.actions,...a.actions,resetApiState:D};return{reducer:h,actions:x}}var he=Symbol.for("RTKQ/skipToken"),Ye={status:"uninitialized"},Je=ae(Ye,()=>{}),Ge=ae(Ye,()=>{});function Xe({serializeQueryArgs:e,reducerPath:r,createSelector:f}){let S=c=>Je,p=c=>Ge;return{buildQuerySelector:M,buildMutationSelector:k,selectInvalidatedBy:Q,selectCachedArgsForQuery:D};function R(c){return{...c,...Be(c.status)}}function A(c){return c[r]}function M(c,o){return n=>{let g=e({queryArgs:n,endpointDefinition:o,endpointName:c});return f(n===he?S:u=>A(u)?.queries?.[g]??Je,R)}}function k(){return c=>{let o;return typeof c=="object"?o=X(c)??he:o=c,f(o===he?p:a=>A(a)?.mutations?.[o]??Ge,R)}}function Q(c,o){let n=c[r],g=new Set;for(let a of o.map(fe)){let d=n.provided[a.type];if(!d)continue;let u=(a.id!==void 0?d[a.id]:De(Object.values(d)))??[];for(let t of u)g.add(t)}return De(Array.from(g.values()).map(a=>{let d=n.queries[a];return d?[{queryCacheKey:a,endpointName:d.endpointName,originalArgs:d.originalArgs}]:[]}))}function D(c,o){return Object.values(c[r].queries).filter(n=>n?.endpointName===o&&n.status!=="uninitialized").map(n=>n.originalArgs)}}import{formatProdErrorMessage as Et}from"@reduxjs/toolkit";var Ze=WeakMap?new WeakMap:void 0,Qe=({endpointName:e,queryArgs:r})=>{let f="",S=Ze?.get(r);if(typeof S=="string")f=S;else{let p=JSON.stringify(r,(R,A)=>(A=typeof A=="bigint"?{$bigint:A.toString()}:A,A=z(A)?Object.keys(A).sort().reduce((M,k)=>(M[k]=A[k],M),{}):A,A));z(r)&&Ze?.set(r,p),f=p}return`${e}(${f})`};import{weakMapMemoize as et}from"reselect";function Me(...e){return function(f){let S=et(Q=>f.extractRehydrationInfo?.(Q,{reducerPath:f.reducerPath??"api"})),p={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...f,extractRehydrationInfo:S,serializeQueryArgs(Q){let D=Qe;if("serializeQueryArgs"in Q.endpointDefinition){let c=Q.endpointDefinition.serializeQueryArgs;D=o=>{let n=c(o);return typeof n=="string"?n:Qe({...o,queryArgs:n})}}else f.serializeQueryArgs&&(D=f.serializeQueryArgs);return D(Q)},tagTypes:[...f.tagTypes||[]]},R={endpointDefinitions:{},batch(Q){Q()},apiUid:ce(),extractRehydrationInfo:S,hasRehydrationInfo:et(Q=>S(Q)!=null)},A={injectEndpoints:k,enhanceEndpoints({addTagTypes:Q,endpoints:D}){if(Q)for(let c of Q)p.tagTypes.includes(c)||p.tagTypes.push(c);if(D)for(let[c,o]of Object.entries(D))typeof o=="function"?o(R.endpointDefinitions[c]):Object.assign(R.endpointDefinitions[c]||{},o);return A}},M=e.map(Q=>Q.init(A,p,R));function k(Q){let D=Q.endpoints({query:c=>({...c,type:"query"}),mutation:c=>({...c,type:"mutation"})});for(let[c,o]of Object.entries(D)){if(Q.overrideExisting!==!0&&c in R.endpointDefinitions){if(Q.overrideExisting==="throw")throw new Error(Et(39));typeof process<"u";continue}R.endpointDefinitions[c]=o;for(let n of M)n.injectEndpoint(c,o)}return A}return A.injectEndpoints({endpoints:f.endpoints})}}import{formatProdErrorMessage as Mt}from"@reduxjs/toolkit";var kt=Symbol();function Bt(){return function(){throw new Error(Mt(33))}}import{enablePatches as wt}from"immer";function H(e,...r){return Object.assign(e,...r)}import{produceWithPatches as Pt}from"immer";var tt=({api:e,queryThunk:r,internalState:f})=>{let S=`${e.reducerPath}/subscriptions`,p=null,R=null,{updateSubscriptionOptions:A,unsubscribeQueryResult:M}=e.internalActions,k=(n,g)=>{if(A.match(g)){let{queryCacheKey:d,requestId:u,options:t}=g.payload;return n?.[d]?.[u]&&(n[d][u]=t),!0}if(M.match(g)){let{queryCacheKey:d,requestId:u}=g.payload;return n[d]&&delete n[d][u],!0}if(e.internalActions.removeQueryResult.match(g))return delete n[g.payload.queryCacheKey],!0;if(r.pending.match(g)){let{meta:{arg:d,requestId:u}}=g,t=n[d.queryCacheKey]??={};return t[`${u}_running`]={},d.subscribe&&(t[u]=d.subscriptionOptions??t[u]??{}),!0}let a=!1;if(r.fulfilled.match(g)||r.rejected.match(g)){let d=n[g.meta.arg.queryCacheKey]||{},u=`${g.meta.requestId}_running`;a||=!!d[u],delete d[u]}if(r.rejected.match(g)){let{meta:{condition:d,arg:u,requestId:t}}=g;if(d&&u.subscribe){let m=n[u.queryCacheKey]??={};m[t]=u.subscriptionOptions??m[t]??{},a=!0}}return a},Q=()=>f.currentSubscriptions,o={getSubscriptions:Q,getSubscriptionCount:n=>{let a=Q()[n]??{};return U(a)},isRequestSubscribed:(n,g)=>!!Q()?.[n]?.[g]};return(n,g)=>{if(p||(p=JSON.parse(JSON.stringify(f.currentSubscriptions))),e.util.resetApiState.match(n))return p=f.currentSubscriptions={},R=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(n))return[!1,o];let a=k(f.currentSubscriptions,n),d=!0;if(a){R||(R=setTimeout(()=>{let m=JSON.parse(JSON.stringify(f.currentSubscriptions)),[,h]=Pt(p,()=>m);g.next(e.internalActions.subscriptionsUpdated(h)),p=m,R=null},500));let u=typeof n.type=="string"&&!!n.type.startsWith(S),t=r.rejected.match(n)&&n.meta.condition&&!!n.meta.arg.subscribe;d=!u&&!t}return[d,!1]}};function vt(e){for(let r in e)return!1;return!0}var Ct=2147483647/1e3-1,nt=({reducerPath:e,api:r,queryThunk:f,context:S,internalState:p})=>{let{removeQueryResult:R,unsubscribeQueryResult:A,cacheEntriesUpserted:M}=r.internalActions,k=G(A.match,f.fulfilled,f.rejected,M.match);function Q(n){let g=p.currentSubscriptions[n];return!!g&&!vt(g)}let D={},c=(n,g,a)=>{if(k(n)){let d=g.getState()[e],u;if(M.match(n))u=n.payload.map(t=>t.queryDescription.queryCacheKey);else{let{queryCacheKey:t}=A.match(n)?n.payload:n.meta.arg;u=[t]}for(let t of u)o(t,d.queries[t]?.endpointName,g,d.config)}if(r.util.resetApiState.match(n))for(let[d,u]of Object.entries(D))u&&clearTimeout(u),delete D[d];if(S.hasRehydrationInfo(n)){let d=g.getState()[e],{queries:u}=S.extractRehydrationInfo(n);for(let[t,m]of Object.entries(u))o(t,m?.endpointName,g,d.config)}};function o(n,g,a,d){let t=S.endpointDefinitions[g]?.keepUnusedDataFor??d.keepUnusedDataFor;if(t===1/0)return;let m=Math.max(0,Math.min(t,Ct));if(!Q(n)){let h=D[n];h&&clearTimeout(h),D[n]=setTimeout(()=>{Q(n)||a.dispatch(R({queryCacheKey:n})),delete D[n]},m*1e3)}}return c};var rt=new Error("Promise never resolved before cacheEntryRemoved."),it=({api:e,reducerPath:r,context:f,queryThunk:S,mutationThunk:p,internalState:R})=>{let A=Ae(S),M=Ae(p),k=O(S,p),Q={};function D(a,d,u){let t=Q[a];t?.valueResolved&&(t.valueResolved({data:d,meta:u}),delete t.valueResolved)}function c(a){let d=Q[a];d&&(delete Q[a],d.cacheEntryRemoved())}let o=(a,d,u)=>{let t=n(a);function m(h,x,T,i){let l=u[r].queries[x],y=d.getState()[r].queries[x];!l&&y&&g(h,i,x,d,T)}if(S.pending.match(a))m(a.meta.arg.endpointName,t,a.meta.requestId,a.meta.arg.originalArgs);else if(e.internalActions.cacheEntriesUpserted.match(a))for(let{queryDescription:h,value:x}of a.payload){let{endpointName:T,originalArgs:i,queryCacheKey:l}=h;m(T,l,a.meta.requestId,i),D(l,x,{})}else if(p.pending.match(a))d.getState()[r].mutations[t]&&g(a.meta.arg.endpointName,a.meta.arg.originalArgs,t,d,a.meta.requestId);else if(k(a))D(t,a.payload,a.meta.baseQueryMeta);else if(e.internalActions.removeQueryResult.match(a)||e.internalActions.removeMutationResult.match(a))c(t);else if(e.util.resetApiState.match(a))for(let h of Object.keys(Q))c(h)};function n(a){return A(a)?a.meta.arg.queryCacheKey:M(a)?a.meta.arg.fixedCacheKey??a.meta.requestId:e.internalActions.removeQueryResult.match(a)?a.payload.queryCacheKey:e.internalActions.removeMutationResult.match(a)?X(a.payload):""}function g(a,d,u,t,m){let h=f.endpointDefinitions[a],x=h?.onCacheEntryAdded;if(!x)return;let T={},i=new Promise(B=>{T.cacheEntryRemoved=B}),l=Promise.race([new Promise(B=>{T.valueResolved=B}),i.then(()=>{throw rt})]);l.catch(()=>{}),Q[u]=T;let y=e.endpoints[a].select(h.type==="query"?d:u),s=t.dispatch((B,P,v)=>v),E={...t,getCacheEntry:()=>y(t.getState()),requestId:m,extra:s,updateCachedData:h.type==="query"?B=>t.dispatch(e.util.updateQueryData(a,d,B)):void 0,cacheDataLoaded:l,cacheEntryRemoved:i},b=x(d,E);Promise.resolve(b).catch(B=>{if(B!==rt)throw B})}return o};var ot=({api:e,context:{apiUid:r},reducerPath:f})=>(S,p)=>{e.util.resetApiState.match(S)&&p.dispatch(e.internalActions.middlewareRegistered(r)),typeof process<"u"};var at=({reducerPath:e,context:r,context:{endpointDefinitions:f},mutationThunk:S,queryThunk:p,api:R,assertTagType:A,refetchQuery:M,internalState:k})=>{let{removeQueryResult:Q}=R.internalActions,D=G(O(S),ee(S)),c=G(O(S,p),Z(S,p)),o=[],n=(d,u)=>{D(d)?a(ge(d,"invalidatesTags",f,A),u):c(d)?a([],u):R.util.invalidateTags.match(d)&&a(se(d.payload,void 0,void 0,void 0,void 0,A),u)};function g(d){for(let u in d.queries)if(d.queries[u]?.status==="pending")return!0;for(let u in d.mutations)if(d.mutations[u]?.status==="pending")return!0;return!1}function a(d,u){let t=u.getState(),m=t[e];if(o.push(...d),m.config.invalidationBehavior==="delayed"&&g(m))return;let h=o;if(o=[],h.length===0)return;let x=R.util.selectInvalidatedBy(t,h);r.batch(()=>{let T=Array.from(x.values());for(let{queryCacheKey:i}of T){let l=m.queries[i],y=k.currentSubscriptions[i]??{};l&&(U(y)===0?u.dispatch(Q({queryCacheKey:i})):l.status!=="uninitialized"&&u.dispatch(M(l)))}})}return n};var st=({reducerPath:e,queryThunk:r,api:f,refetchQuery:S,internalState:p})=>{let R={},A=(o,n)=>{(f.internalActions.updateSubscriptionOptions.match(o)||f.internalActions.unsubscribeQueryResult.match(o))&&k(o.payload,n),(r.pending.match(o)||r.rejected.match(o)&&o.meta.condition)&&k(o.meta.arg,n),(r.fulfilled.match(o)||r.rejected.match(o)&&!o.meta.condition)&&M(o.meta.arg,n),f.util.resetApiState.match(o)&&D()};function M({queryCacheKey:o},n){let g=n.getState()[e],a=g.queries[o],d=p.currentSubscriptions[o];if(!a||a.status==="uninitialized")return;let{lowestPollingInterval:u,skipPollingIfUnfocused:t}=c(d);if(!Number.isFinite(u))return;let m=R[o];m?.timeout&&(clearTimeout(m.timeout),m.timeout=void 0);let h=Date.now()+u;R[o]={nextPollTimestamp:h,pollingInterval:u,timeout:setTimeout(()=>{(g.config.focused||!t)&&n.dispatch(S(a)),M({queryCacheKey:o},n)},u)}}function k({queryCacheKey:o},n){let a=n.getState()[e].queries[o],d=p.currentSubscriptions[o];if(!a||a.status==="uninitialized")return;let{lowestPollingInterval:u}=c(d);if(!Number.isFinite(u)){Q(o);return}let t=R[o],m=Date.now()+u;(!t||m<t.nextPollTimestamp)&&M({queryCacheKey:o},n)}function Q(o){let n=R[o];n?.timeout&&clearTimeout(n.timeout),delete R[o]}function D(){for(let o of Object.keys(R))Q(o)}function c(o={}){let n=!1,g=Number.POSITIVE_INFINITY;for(let a in o)o[a].pollingInterval&&(g=Math.min(o[a].pollingInterval,g),n=o[a].skipPollingIfUnfocused||n);return{lowestPollingInterval:g,skipPollingIfUnfocused:n}}return A};var ut=({api:e,context:r,queryThunk:f,mutationThunk:S})=>{let p=pe(f,S),R=Z(f,S),A=O(f,S),M={};return(Q,D)=>{if(p(Q)){let{requestId:c,arg:{endpointName:o,originalArgs:n}}=Q.meta,g=r.endpointDefinitions[o],a=g?.onQueryStarted;if(a){let d={},u=new Promise((x,T)=>{d.resolve=x,d.reject=T});u.catch(()=>{}),M[c]=d;let t=e.endpoints[o].select(g.type==="query"?n:c),m=D.dispatch((x,T,i)=>i),h={...D,getCacheEntry:()=>t(D.getState()),requestId:c,extra:m,updateCachedData:g.type==="query"?x=>D.dispatch(e.util.updateQueryData(o,n,x)):void 0,queryFulfilled:u};a(n,h)}}else if(A(Q)){let{requestId:c,baseQueryMeta:o}=Q.meta;M[c]?.resolve({data:Q.payload,meta:o}),delete M[c]}else if(R(Q)){let{requestId:c,rejectedWithValue:o,baseQueryMeta:n}=Q.meta;M[c]?.reject({error:Q.payload??Q.error,isUnhandledError:!o,meta:n}),delete M[c]}}};var yt=({reducerPath:e,context:r,api:f,refetchQuery:S,internalState:p})=>{let{removeQueryResult:R}=f.internalActions,A=(k,Q)=>{V.match(k)&&M(Q,"refetchOnFocus"),W.match(k)&&M(Q,"refetchOnReconnect")};function M(k,Q){let D=k.getState()[e],c=D.queries,o=p.currentSubscriptions;r.batch(()=>{for(let n of Object.keys(o)){let g=c[n],a=o[n];if(!a||!g)continue;(Object.values(a).some(u=>u[Q]===!0)||Object.values(a).every(u=>u[Q]===void 0)&&D.config[Q])&&(U(a)===0?k.dispatch(R({queryCacheKey:n})):g.status!=="uninitialized"&&k.dispatch(S(g)))}})}return A};function dt(e){let{reducerPath:r,queryThunk:f,api:S,context:p}=e,{apiUid:R}=p,A={invalidateTags:L(`${r}/invalidateTags`)},M=c=>c.type.startsWith(`${r}/`),k=[ot,nt,at,st,it,ut];return{middleware:c=>{let o=!1,g={...e,internalState:{currentSubscriptions:{}},refetchQuery:D,isThisApiSliceAction:M},a=k.map(t=>t(g)),d=tt(g),u=yt(g);return t=>m=>{if(!Ce(m))return t(m);o||(o=!0,c.dispatch(S.internalActions.middlewareRegistered(R)));let h={...c,next:t},x=c.getState(),[T,i]=d(m,h,x),l;if(T?l=t(m):l=i,c.getState()[r]&&(u(m,h,x),M(m)||p.hasRehydrationInfo(m)))for(let y of a)y(m,h,x);return l}},actions:A};function D(c){return e.api.endpoints[c.endpointName].initiate(c.originalArgs,{subscribe:!1,forceRefetch:!0})}}var Se=Symbol(),ke=({createSelector:e=Pe}={})=>({name:Se,init(r,{baseQuery:f,tagTypes:S,reducerPath:p,serializeQueryArgs:R,keepUnusedDataFor:A,refetchOnMountOrArgChange:M,refetchOnFocus:k,refetchOnReconnect:Q,invalidationBehavior:D},c){wt();let o=C=>(typeof process<"u",C);Object.assign(r,{reducerPath:p,endpoints:{},internalActions:{onOnline:W,onOffline:re,onFocus:V,onFocusLost:ne},util:{}});let{queryThunk:n,mutationThunk:g,patchQueryData:a,updateQueryData:d,upsertQueryData:u,prefetch:t,buildMatchThunkActions:m}=ze({baseQuery:f,reducerPath:p,context:c,api:r,serializeQueryArgs:R,assertTagType:o}),{reducer:h,actions:x}=$e({context:c,queryThunk:n,mutationThunk:g,serializeQueryArgs:R,reducerPath:p,assertTagType:o,config:{refetchOnFocus:k,refetchOnReconnect:Q,refetchOnMountOrArgChange:M,keepUnusedDataFor:A,reducerPath:p,invalidationBehavior:D}});H(r.util,{patchQueryData:a,updateQueryData:d,upsertQueryData:u,prefetch:t,resetApiState:x.resetApiState,upsertQueryEntries:x.cacheEntriesUpserted}),H(r.internalActions,x);let{middleware:T,actions:i}=dt({reducerPath:p,context:c,queryThunk:n,mutationThunk:g,api:r,assertTagType:o});H(r.util,i),H(r,{reducer:h,middleware:T});let{buildQuerySelector:l,buildMutationSelector:y,selectInvalidatedBy:s,selectCachedArgsForQuery:E}=Xe({serializeQueryArgs:R,reducerPath:p,createSelector:e});H(r.util,{selectInvalidatedBy:s,selectCachedArgsForQuery:E});let{buildInitiateQuery:b,buildInitiateMutation:B,getRunningMutationThunk:P,getRunningMutationsThunk:v,getRunningQueriesThunk:w,getRunningQueryThunk:_}=He({queryThunk:n,mutationThunk:g,api:r,serializeQueryArgs:R,context:c});return H(r.util,{getRunningMutationThunk:P,getRunningMutationsThunk:v,getRunningQueryThunk:_,getRunningQueriesThunk:w}),{name:Se,injectEndpoint(C,q){let N=r;N.endpoints[C]??={},me(q)?H(N.endpoints[C],{name:C,select:l(C,q),initiate:b(C,q)},m(n,C)):je(q)&&H(N.endpoints[C],{name:C,select:y(),initiate:B(C)},m(g,C))}}}});var Ft=Me(ke());export{Re as QueryStatus,kt as _NEVER,Me as buildCreateApi,le as copyWithStructuralSharing,ke as coreModule,Se as coreModuleName,Ft as createApi,Qe as defaultSerializeQueryArgs,Bt as fakeBaseQuery,mt as fetchBaseQuery,Qt as retry,St as setupListeners,he as skipToken};
//# sourceMappingURL=rtk-query.browser.mjs.map